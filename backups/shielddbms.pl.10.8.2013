#!/usr/bin/perl -w
#
# Reboot of shieldb file
# 10.05.2013
# weaknetlabs@gmail.com
#
use strict;

# global variables
my @ARGV; # reserved
my $db = "";

# Subroutine prototypes
sub prompt();
sub cmd($);
sub msg($);
sub createdb($);
sub createtbl($);
sub show($);
sub error($$);
sub help($);
sub quit();
sub n();
sub desc($);
sub sel($);
sub format($$);

if(!$ARGV[0]){
	prompt() while (1);
}

sub prompt(){
	my $dbn = $db;
	$dbn = "none" if($dbn eq "");
	printf("ShieldDB:(%s)> ",$dbn);
	my $cmd = <STDIN>;
	chomp $cmd;
	cmd($cmd);
}

sub cmd($){
	return if($_[0] eq ""); # newline
	my $cmd = $_[0];
	if($cmd =~ m/^(quit|exit)/i){
		quit(); # don't be invasive
	}elsif($cmd !~ m/;$/){
		error("SYNTAX","please terminate your commands with a semi-colon");
	}elsif($cmd =~ m/^use /i){
		usedb($cmd);
	}elsif($cmd =~ m/^create database/i){
		createdb($cmd); # create a db directory
	}elsif($cmd =~ m/^help/i){
		help($cmd);
	}elsif($cmd =~ m/^create table/i){
		createtbl($cmd);
	}elsif($cmd =~ m/^show /i){
		show($cmd);
	}elsif($cmd =~ m/^describe /i){
		desc($cmd);
	}elsif($cmd =~ m/^select /i){
		sel($cmd);
	}


	else{
		error("DBMS","command not yet implemented");
	}
}

### SQL COMMANDS ###

sub sel($){
	my $table = $_[0];
	my $cols = $_[0];
	my %cols; # hash columnname => int++
	my $where = 0; # where boolean
	my %where; # columnname => value user wants
	$where = 1 if($table =~ m/ where /i); # boolean true
	$table =~ s/.* from ([a-z0-9_-]+).*/$1/i;
	$cols =~ s/^select ([a-z0-9_,.*-]+).*/$1/i;
	open (TBL,"db_".$db."/tables/".$table.".tbl");
	my @desc = split(/,/,scalar <TBL>); # shift and get descriptor
	for(my $i=0;$i<=$#desc;$i++){
		$desc[$i] =~ s/ .*//; # get rid of constraints
		chomp $desc[$i];
		$cols{$desc[$i]} = $i;
	}
	my @where = split(/ and /,$_[0]);
	for(my $i=0;$i<=$#where;$i++){
		$where[$i] =~ s/^.* where //;
		my @tmpsplt = split(/ = /,$where[$i]);
		$tmpsplt[1] =~ s/["';]//g; # remove quotes
		$where{$tmpsplt[0]} = $tmpsplt[1];
	}
	my @cols; # array of columns we want to display
	if($cols eq '*'){
		push (@cols,$_) foreach(@desc); # select *
	}elsif($cols =~ m/,/){
		push(@cols,split(/,/,$cols)); # comma sep
	}else{
		push(@cols,$cols); # just one column
	} # now let's loop the rest of the table:
	while(<TBL>){ # name,email = 1,2
		chomp $_;
		my $record = "";
		my @recsplt = split(/,/,$_);
		foreach(@cols){
			if($where){
				if($where{$_} eq $recsplt[$cols{$_}]){
					$record .= $recsplt[$cols{$_}] . ",";
				}else{
					$record = ""; # reset the record because of
					next; # mismatch or partial match; not acceptable
				}
			}else{
				$record .= $recsplt[$cols{$_}] . ",";
			}
		}
		printf("%s\n",$record) if($record ne "");
	}
	close TBL; # complete!
}

sub format($$){ # format(column length,value length);
	my $string = "-"; 
	$string .= "+"; # add a plus at the end
	return $string; # e.g. "------------+" per column
}

sub usedb($){
	# grab the database from the command
	my $dbs = $_[0]; # database selected
	$dbs =~ s/^use ([a-z0-9_-]+).*/$1/i;
	# check for existence:
	if (-r "db_" . $dbs){
		$db = $dbs;
		msg("now using database: " . $db);
	}else{
		error("DB","database " . $dbs . " does not exist");
	}
	return;
}

sub createdb($){
	my $cdb = $_[0];
	$cdb =~ s/^cre.* ([a-z0-9_-]+).*/$1/i;
	msg("creating database " . $cdb);
	if(mkdir("db_".$cdb) && mkdir("db_".$cdb."/tables/")){
		msg("database creation successful");
	}else{
		error("FSE","could not create database files");
	}
	return;
}

sub createtbl($){
	if($db eq ""){ # no database selected
		error("DB","no database selected to store new table");
		return;
	}
	my $tbl = $_[0];
	$tbl =~ s/^create table ([a-z0-9_-]+).*/$1/;
	my $desc = $_[0];
	my $regex = ".*".$tbl."\\((.*)\\);\$";
	$desc =~ s/$regex/$1/;
	if($desc =~ m/^create tab/i){ # good enough for now, TODO
		error("SYNTAX","descriptor is invalid for table " . $tbl);
		return;
	}
	msg("creating table " . $tbl . " with descriptor " . $desc);
	if(open(TBL,">db_".$db."/tables/".$tbl.".tbl")){ # tbl extension
		print TBL $desc . "\n";
		close TBL;
	}else{
		error("FSE","could not create table file in database " . $db);
	}	
	return;
}

sub show($){
	if($db eq ""){
		error("DB","no database selected to show items");
		return;
	}
	my $what = $_[0];
	$what =~ s/^show ([a-z]+).*/$1/;
	msg("showing ".$what." in ".$db);
	if($what ne "tables"){
		error("SYNTAX","what should I show you?");
		return;
	}elsif($what eq "tables"){
		if(opendir(DB,"db_".$db."/tables/")){
		n();
			while(my $tbl = readdir(DB)){
				$tbl =~ s/\.tbl//;
				if($tbl !~ m/^\./){
					printf(" %s \n",$tbl);
				}
			}
		n();
		closedir(DB);
		}else{
			error("DB","database does not exist or could not be read on current filesystem");
		}
	} # all done.
	return;
}

sub desc($){ # describe the table using it's first line descriptor
	my $desc; # decription semi-global to be returned
	if($db eq ""){
		error("DB","database not yet selected, try \"use\" command or \"help use\"");
		return;
	}
	my $what = $_[0];
	$what =~ s/desc.* ([a-z0-9_-]+).*/$1/;
	msg("description for " . $what);
	n();
	if(open(TBL,"db_".$db."/tables/".$what.".tbl")){
		my @l = split(/,/,scalar <TBL>);
		foreach(@l){
			chomp $_;
			$desc = $_;
			my $col = $_;
			$col =~ s/ .*//;
			$desc =~ s/^[a-z0-9_-]+ //i; # id int not null auto_increment
			print " " . $col . "\n\t-> $desc\n";
		}	
		n();
	}else{
		error("TBL","table ".$what." does not exist");
		return;
	}
	return $desc;
}

### GENERIC COMMANDS: ###
sub msg($){
	printf(" -> %s\n",$_[0]);
	return;
}

sub error($$){ # i realize this could be msg($) with an extra arg
	printf(" -> There was an error of type: %s\n -> MSG: %s\n",$_[0],$_[1]);
	return;
}

sub help($){
	n();
	my $what = $_[0];
	my $hb = 0; # help boolean
	$what =~ s/^help\s?([a-z0-9_-]+)?;$/$1/i;
	#$what =~ s/;$//; # get rid of syntax lol
	if($what eq ""){ # generic help:
		if(open(CMNL,"manual/commands.csv")){
			printf(" == SHIELDDB SQL COMMANDS ==\n\n");
			while(<CMNL>){
				my @l = split(/,/,$_);
				printf(" -> %s\n",shift(@l)); # grab the first line
				foreach(@l){ # the rest of the line
					my $l = $_;
					$l =~ s/_/,/g; # because we can't edit $_ - fooey!
					printf("\t=> %s\n",$l);
				}
			}
			close(CMNL);
		}else{
			error("FSE","missing commands manual");
		}
	}else{
		if(open(CMNL,"manual/commands.csv")){
			while(<CMNL>){
				my @l = split(/,/,$_);
				if($l[0] eq $what){
					$hb = 1;
					printf(" -> %s\n",shift(@l)); # grab the first line
					foreach(@l){ # the rest of the line
						my $l = $_;
						$l =~ s/_/,/g; # because we can't edit $_ - fooey!
						printf("\t=> %s\n",$l);
					}
				}
			}
		}else{
			error("FSE","missing commands manual");
		}
	}
	if(!$hb){
		printf(" no help for " . $what . "\n");
	}
	return;
}
sub n(){
	printf("\n");
}
sub quit(){
	printf("Goodbye\n");
	# clean up files here
	exit;
}
