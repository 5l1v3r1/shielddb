#!/usr/bin/perl -w
#
# Shield DB DBMS TOOL (c) GNU 3.0
# Code began 10.05.2013 by
# Douglas Berdeaux
# weaknetlabs@gmail.com
#
use strict;

# global variables
my @ARGV; # reserved
my $db = ""; # which database in use?

# Subroutine prototypes
sub prompt();     # display the prompt
sub cmd($);       # processing each command
sub msg($);       # message dialog
sub createdb($);  # create database and all files
sub createtbl($); # create table
sub show($);      # show tables
sub error($$);    # error output with code
sub help($);      # help dialog
sub quit();       # exit / file clean up
sub n();          # new line
sub desc($$);      # get the descriptor for a table
sub sel($);       # SQL SELECT query
sub format($$);   # formatting the output
sub clone($);     # cloning a table or database
sub retdate();    # return the date
sub drop($);      # delete stuff! \m/
sub chkdb();	  # anywhere we NEED a $db put a: "return if chkdb();"
sub insert($);	  # SQL INSERT query

if(!$ARGV[0]){
	prompt() while (1); # to infinity and beyond!
}

sub prompt(){
	my $dbn = $db;
	$dbn = "none" if($dbn eq "");
	my $date = retdate();
	printf("ShieldDB: %s (%s)> ",$date,$dbn);
	my $cmd = <STDIN>;
	chomp $cmd;
	cmd($cmd);
}

sub cmd($){
	return if($_[0] eq ""); # newline
	my $cmd = $_[0];
	if($cmd =~ m/^(quit|exit)/i){
		quit(); # don't be invasive
	}elsif($cmd !~ m/;$/){
		error("SYNTAX","please terminate your commands with a semi-colon");
	}elsif($cmd =~ m/^use /i){
		usedb($cmd);
	}elsif($cmd =~ m/^create database/i){
		createdb($cmd); # create a db directory
	}elsif($cmd =~ m/^help/i){
		help($cmd);
	}elsif($cmd =~ m/^create table/i){
		return if chkdb();
		createtbl($cmd);
	}elsif($cmd =~ m/^show /i){
		return if chkdb();
		show($cmd);
	}elsif($cmd =~ m/^describe /i){
		return if chkdb();
		desc($cmd,1);
	}elsif($cmd =~ m/^select /i){
		return if chkdb();
		sel($cmd);
	}elsif($cmd =~ m/^clone /i){
		clone($cmd); # copy a table or db
	}elsif($cmd =~ m/^drop /i){
		drop($cmd); # drop a table or db
	}elsif($cmd =~ m/^insert /){
		return if chkdb();
		insert($cmd); # our insert SQL query!
	}
	else{
		error("DBMS","command not yet implemented");
	}
}

### SQL COMMANDS ###

sub sel($){
	my $table = $_[0];
	my $cols = $_[0];
	my %cols; # hash columnname => int++
	my $where = 0; # where boolean
	my %where; # columnname => value user wants
	$where = 1 if($table =~ m/ where /i); # boolean true
	$table =~ s/.* from ([a-z0-9_-]+).*/$1/i;
	$cols =~ s/^select ([a-z0-9_,.*-]+).*/$1/i;
	open (TBL,"db_".$db."/tables/".$table.".tbl");
	my @desc = split(/,/,scalar <TBL>); # shift and get descriptor
	for(my $i=0;$i<=$#desc;$i++){
		$desc[$i] =~ s/ .*//; # get rid of constraints
		chomp $desc[$i];
		$cols{$desc[$i]} = $i;
	}
	if($where){
		my @where = split(/ and /,$_[0]);
		for(my $i=0;$i<=$#where;$i++){
			$where[$i] =~ s/^.* where //;
			my @tmpsplt = split(/ = /,$where[$i]);
			$tmpsplt[1] =~ s/["';]//g; # remove quotes
			$where{$tmpsplt[0]} = $tmpsplt[1];
		}
	}
	my @cols; # array of columns we want to display
	if($cols eq '*'){
		push (@cols,$_) foreach(@desc); # select *
	}elsif($cols =~ m/,/){
		push(@cols,split(/,/,$cols)); # comma sep
	}else{
		push(@cols,$cols); # just one column
	} # now let's loop the rest of the table:
	while(<TBL>){ # name,email = 1,2
		chomp $_;
		my $record = "";
		my @recsplt = split(/,/,$_);
		foreach(@cols){
			if($where && $where{$_}){
				if($where{$_} =~ m/^\/(.*)\/i?$/){ # using regular expressions here	
					my $wh = $where{$_};
					my $igcase;
					$igcase = 1 if($wh =~ m/\/i$/);
					$wh =~ s/^.(.*).i?$/$1/; # drop the syntax, and step away
					if($recsplt[$cols{$_}] =~ m/$wh/){   # from the keyboard!
						$record .= $recsplt[$cols{$_}] . ",";
					}else{
						$record = "";
						last;
					}
				}else{
					if($where{$_} eq $recsplt[$cols{$_}]){
						$record .= $recsplt[$cols{$_}] . ",";
					}else{
						$record = ""; # reset the record because of
						last; # mismatch or partial match; not acceptable
					}
				}
			}else{
				$record .= $recsplt[$cols{$_}] . ",";
			}
		}
		printf("%s\n",$record) if($record ne "");
	}
	close TBL; # complete!
}

sub format($$){ # format(column length,value length);
	my $string = "-"; 
	$string .= "+"; # add a plus at the end
	return $string; # e.g. "------------+" per column
}

sub usedb($){
	my $dbs = $_[0]; # database selected
	$dbs =~ s/^use ([a-z0-9_-]+).*/$1/i;
	if($dbs eq "null" || $dbs eq "none"){ $db = "none"; return; }
	if (-r "db_" . $dbs){ # does it exist?
		$db = $dbs;
		msg("now using database: " . $db);
	}else{
		error("DB","database " . $dbs . " does not exist");
	}
	return;
}

sub createdb($){
	my $cdb = $_[0];
	$cdb =~ s/^cre.* ([a-z0-9_-]+).*/$1/i;
	msg("creating database " . $cdb);
	if(mkdir("db_".$cdb) && mkdir("db_".$cdb."/tables/")){
		msg("database creation successful");
	}else{
		error("FSE","could not create database files");
	}
	return;
}

sub createtbl($){
	if($db eq ""){ # no database selected
		error("DB","no database selected to store new table");
		return;
	}
	my $tbl = $_[0];
	$tbl =~ s/^create table ([a-z0-9_-]+).*/$1/;
	my $desc = $_[0];
	my $regex = ".*".$tbl."\\((.*)\\);\$";
	$desc =~ s/$regex/$1/;
	if($desc =~ m/^create tab/i){ # good enough for now, TODO
		error("SYNTAX","descriptor is invalid for table " . $tbl);
		return;
	}
	msg("creating table " . $tbl . " with descriptor " . $desc);
	if(open(TBL,">db_".$db."/tables/".$tbl.".tbl")){ # tbl extension
		print TBL $desc . "\n";
		close TBL;
	}else{
		error("FSE","could not create table file in database " . $db);
	}	
	return;
}

sub show($){
	if($db eq ""){
		error("DB","no database selected to show items");
		return;
	}
	my $what = $_[0];
	$what =~ s/^show ([a-z]+).*/$1/;
	msg("showing ".$what." in ".$db);
	if($what ne "tables"){
		error("SYNTAX","what should I show you?");
		return;
	}elsif($what eq "tables"){
		if(opendir(DB,"db_".$db."/tables/")){
		n();
			while(my $tbl = readdir(DB)){
				$tbl =~ s/\.tbl//;
				if($tbl !~ m/^\./){
					printf(" %s \n",$tbl);
				}
			}
		n();
		closedir(DB);
		}else{
			error("DB","database does not exist or could not be read on current filesystem");
		}
	} # all done.
	return;
}

sub desc($$){ # describe the table using it's first line descriptor
	my $desc; # decription semi-global to be returned
	my $old; # one liner description
	if($db eq ""){
		error("DB","database not yet selected, try \"use\" command or \"help use\"");
		return;
	}
	my $what = $_[0];
	$what =~ s/desc.* ([a-z0-9_-]+).*/$1/;
	if($_[1]){ # only if told to
		msg("description for " . $what);
		n();
	}
	if(open(TBL,"db_".$db."/tables/".$what.".tbl")){
		my @l = split(/,/,scalar <TBL>);
		foreach(@l){
			my $l = $_;
			chomp $l;
			$desc = $l;
			my $col = $l;
			$col =~ s/ .*//;
			$desc =~ s/^[a-z0-9_-]+ //i; # id int not null auto_increment
			print " column: " . $col . "\n   -> $desc\n" if($_[1]); # print boolean?
			$old .= $desc . ",";
		}	
		n() if($_[1]);
	}else{
		error("TBL","table ".$what." does not exist");
		return;
	}
	return $old; # one liner description
}

sub clone($){ # clone database foo as bar
	my $type = $_[0];
	$type =~ s/^clone ([a-z]+).*/$1/i;
	my $what = $_[0];
	$what =~ s/^.*(base|table) ([a-z0-9_-]+).*/$2/i;
	my $as = $_[0];
	$as =~ s/^.* as ([a-z0-9_-]+).*/$1/i;
	if($type ne "database" && $type ne "table"){
		error("NTD","cannot clone a " . $type . " please check \"help\" for syntax");
		return;
	}else{
		if($what ne "" && $as ne ""){
			if($type eq "table"){ # cloning a table (easy)
				return if chkdb();
				msg("cloning " . $type . " " . $what . " as " . $as);
				open(TBLAS,">db_".$db."/tables/".$as.".tbl");
				if(!open(TBLWH,"db_".$db."/tables/".$what.".tbl")){
					error("DB","table " . $what  . " does not exist in current database");
					return 1;
				}
				print TBLAS $_ while(<TBLWH>);
				close TBLAS;
				close TBLWH;
				return;
			}elsif($type eq "database" or $type eq "db"){
				msg("cloning " . $type . " " . $what . " as " . $as);
				# let us do a try with just cp -R (GNU needed)
				system("cp -R db_" . $what . " db_" . $as);
				if(opendir(DIR,"db_".$as)){
					msg("database cloning completed successfully for " . $as);
					closedir(DIR); # close her up
				}else{
					error("FSE","could not write to dbms root");
				}
			}
		}else{ # TODO: add specifics!
			error("SYNTAX","please check \"help\" for proper syntax");
			return;
		}
	}
}
sub drop($){
	my $type = $_[0]; # type of thing to drop
	my $what = $_[0]; # drop what?
	$type =~ s/^drop ([a-z]+) .*/$1/i;
	$what =~ s/^.*p ([a-z]+) ([a-z0-9_-]+).*/$2/i;
	if($type ne "table" && $type ne "database" && $type ne "db"){
		error("SYNTAX","i cannot drop a " . $type . " please check \"help\" for syntax");
		return 1;
	}
	msg("dropping " . $type . " " . $what);
	if($type eq "table"){
		return if chkdb(); # no database set
		if(unlink "db_".$db."/tables/".$what.".tbl"){
			msg("table file unlinked from filesystem successfully");
		}else{
			error("FSE","could not unlink table file, permission error?");
			return 1;
		}
	}else{
		opendir(DH,"db_".$what."/tables/");
		my @tbls = readdir DH;
		closedir DH;	
		foreach(@tbls){ unlink "db_".$what."/tables/".$_; } # remove all tables, add more files if db dir grows.
		rmdir "db_".$what."/tables/"; # remove tables directory
		rmdir ("db_".$what); # remove parent directory
	}
	return;
}

sub insert($){ # insert into users values(NULL,"4nalysis","analytical@wnl.com");
	my $tbl = $_[0];
	chomp $tbl;
	my $valine = $tbl;
	$tbl =~ s/.* into ([a-z0-9_-]+).*/$1/;
	if(!open(TBL,">>db_".$db."/tables/".$tbl.".tbl")){
		error("DB","table " . $tbl . " does not exist");
		return 1;
	}
	$valine =~ s/^.*\((.*)\);$/$1/; # should technically always be the same?
	my @vals = split(/,/,$valine);  # INSERT VALUES
	my @const = split(/,/,desc($tbl,0)); # int not null auto_increment,varchar(15),varchar(35),
	if($#vals != $#const){ # value count is wrong
		error("DB","you have entered the wrong number of values"); # TODO get numbers and compare
		return 1;
	}else{ # check constraints
		for(my $i=0;$i<=$#vals;$i++){
			if($const[$i] =~ m/int/i && $vals[$i] !~ m/\D/ && $const[$i] !~ m/auto_increment/i){
				next;
			}elsif($const[$i] =~ m/auto_increment/i && $vals[$i] eq "NULL" && $const[$i] =~ m/not null/i){
				while(<TBL>){ # get last value
					my @rec = split(/,/,$_);
					$vals[$i] = int($rec[$i])+1; # just keep grabbing the value until last record
				}
			}elsif($const[$i] =~ m/not null/i && $vals[$i] eq "NULL" && $const[$i] !~ m/auto_increment/i){
				error("DB","data insertion failed. the value entered for column " . int($i+1) . " is not correct");
				return 1;
			}elsif($const[$i] =~ m/varchar/i){
				my $max = $const[$i];
				$max =~ s/.*\(([0-9]+).*/$1/; # make integer
				$max = int($max);
				if(length($vals[$i]) <= $max){ # length constraint
					next;
				}else{ # rather than truncate, error out.
					error("DB","data insertion failed. the value entered for column " . int($i+1) . " is not correct");
					return 1;
				}
			}else{
				error("DB","data insertion failed. the value entered for column " . int($i+1) . " is not correct");
				return 1;
			}
		}
		close TBL;
		open(TBL,">>db_".$db."/tables/".$tbl.".tbl");
		my $record;
		$record .= $_ . "," foreach(@vals);
		$record =~ s/,$//; # tailgater!
		print TBL $record . "\n"; # insert it :)
		close TBL;
	}
	return 0;
}

### GENERIC COMMANDS: ###
sub retdate(){ # for logging and prompt
	my @date = localtime;
	for(my $i=0;$i<=2;$i++){ # only use 0,1,2 elements
		$date[$i] = "0" . $date[$i] if(length($date[$i]) < 2);
	}
	return $date[2] . ":" . $date[1] . ":" . $date[0];
}
sub msg($){
	printf(" -> %s\n",$_[0]);
	return;
}

sub error($$){ # printing to STDERR
	print STDERR (" -> There was an error of type: " . $_[0] . " \n -> MSG: " . $_[1] . "\n");
	return 1;
}

sub help($){
	n();
	my $what = $_[0];
	my $hb = 0; # help boolean
	$what =~ s/^help\s?([a-z0-9_;-]+)?/$1/i;
	$what =~ s/;$//;
	if($what eq ""){ # generic help:
		if(open(CMNL,"manual/commands.csv")){
			printf(" == SHIELDDB SQL COMMANDS ==\n\n");
			while(<CMNL>){
				my @l = split(/,/,$_);
				printf(" -> %s\n",shift(@l)); # grab the first line
				foreach(@l){ # the rest of the line
					my $l = $_;
					$l =~ s/_/,/g; # because we can't edit $_ - fooey!
					$l =~ s/auto,increment/auto_increment/; # dirty fix for now
					printf("\t=> %s\n",$l);
				}
				$hb = 1;
			}
			close(CMNL);
		}else{
			error("FSE","missing commands manual");
		}
	}else{
		if(open(CMNL,"manual/commands.csv")){
			while(<CMNL>){
				my @l = split(/,/,$_);
				if($l[0] eq $what){
					$hb = 1;
					printf(" -> %s\n",shift(@l)); # grab the first line
					foreach(@l){ # the rest of the line
						my $l = $_;
						$l =~ s/_/,/g; # because we can't edit $_ - fooey!
						$l =~ s/auto,increment/auto_increment/; # dirty fix for now
						printf("\t=> %s\n",$l);
					}
				}
			}
		}else{
			error("FSE","missing commands manual");
		}
	}
	if(!$hb){
		printf(" no help for " . $what . "\n");
	}
	return;
}

sub chkdb(){
	if($db eq ""){
		error("DB","please first choose a database");
		return 1;
	}
}

sub n(){
	printf("\n");
}
sub quit(){
	printf("Goodbye\n");
	# clean up files here
	exit;
}
